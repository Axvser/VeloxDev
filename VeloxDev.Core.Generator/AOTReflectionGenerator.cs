using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace VeloxDev.Core.Generator
{
    [Generator(LanguageNames.CSharp)]
    public sealed class AOTReflectionGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Step 1: 收集当前项目中带有 [AOTReflection] 的类型
            var localTypes = context.SyntaxProvider
                .CreateSyntaxProvider(
                    static (s, _) => s is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0,
                    static (ctx, _) =>
                    {
                        var cds = (ClassDeclarationSyntax)ctx.Node;
                        foreach (var list in cds.AttributeLists)
                        {
                            foreach (var attr in list.Attributes)
                            {
                                var symbol = ctx.SemanticModel.GetSymbolInfo(attr).Symbol?.ContainingType;
                                if (symbol is null) continue;
                                if (symbol.ToDisplayString() == "VeloxDev.Core.AOT.AOTReflectionAttribute")
                                {
                                    var typeSymbol = ctx.SemanticModel.GetDeclaredSymbol(cds) as INamedTypeSymbol;
                                    if (typeSymbol != null)
                                        return typeSymbol;
                                }
                            }
                        }
                        return null;
                    })
                .Where(static t => t is not null)!;

            // Step 2: 组合 Compilation 与本地标记类型
            var compilationAndLocal = context.CompilationProvider.Combine(localTypes.Collect());

            // Step 3: 注册输出
            context.RegisterSourceOutput(compilationAndLocal, static (spc, pair) =>
            {
                var (compilation, localTypeSymbols) = pair;

                // 收集本地与外部程序集的所有标记类型
                var allMarkedTypes = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

                // 本地标记
                foreach (var t in localTypeSymbols)
                    allMarkedTypes.Add(t!);

                // 外部程序集标记
                foreach (var asm in compilation.SourceModule.ReferencedAssemblySymbols)
                {
                    foreach (var type in GetTypesWithAOTReflection(asm))
                    {
                        allMarkedTypes.Add(type);
                    }
                }

                // 生成源码
                var source = GenerateAOTReflectionSource(allMarkedTypes);
                spc.AddSource("AOTReflection.g.cs", SourceText.From(source, Encoding.UTF8));
            });
        }

        /// <summary>
        /// 扫描程序集中的所有类型，找出带 [AOTReflection] 的
        /// </summary>
        private static IEnumerable<INamedTypeSymbol> GetTypesWithAOTReflection(IAssemblySymbol asm)
        {
            foreach (var ns in GetAllNamespaces(asm.GlobalNamespace))
            {
                foreach (var type in ns.GetTypeMembers())
                {
                    if (HasAOTReflectionAttribute(type))
                        yield return type;

                    foreach (var nested in GetNestedTypes(type))
                    {
                        if (HasAOTReflectionAttribute(nested))
                            yield return nested;
                    }
                }
            }
        }

        private static bool HasAOTReflectionAttribute(INamedTypeSymbol type)
        {
            return type.GetAttributes().Any(a =>
                a.AttributeClass?.ToDisplayString() == "VeloxDev.Core.AOT.AOTReflectionAttribute");
        }

        private static IEnumerable<INamedTypeSymbol> GetNestedTypes(INamedTypeSymbol type)
        {
            foreach (var nested in type.GetTypeMembers())
            {
                yield return nested;
                foreach (var deeper in GetNestedTypes(nested))
                    yield return deeper;
            }
        }

        private static IEnumerable<INamespaceSymbol> GetAllNamespaces(INamespaceSymbol ns)
        {
            yield return ns;
            foreach (var child in ns.GetNamespaceMembers())
                foreach (var n in GetAllNamespaces(child))
                    yield return n;
        }

        private static string GenerateAOTReflectionSource(IEnumerable<INamedTypeSymbol> types)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Reflection;");
            sb.AppendLine();
            sb.AppendLine("namespace VeloxDev.Core");
            sb.AppendLine("{");
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// 自动生成的 AOT 反射初始化类");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public static class AOTReflection");
            sb.AppendLine("    {");
            sb.AppendLine("        public static void Init()");
            sb.AppendLine("        {");

            var list = types.ToList();
            if (list.Count == 0)
            {
                sb.AppendLine("            // 未发现带 [AOTReflection] 的类型");
            }
            else
            {
                foreach (var type in list.Distinct(SymbolEqualityComparer.Default))
                {
                    var fullName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    sb.AppendLine($"            // {fullName}");
                    sb.AppendLine($"            _ = typeof({fullName}).GetTypeInfo();");

                    var attr = type.GetAttributes().FirstOrDefault(a =>
                        a.AttributeClass?.ToDisplayString() == "VeloxDev.Core.AOT.AOTReflectionAttribute");

                    bool includeCtors = GetNamedArg(attr, "IncludeConstructors", true);
                    bool includeMethods = GetNamedArg(attr, "IncludeMethods", true);
                    bool includeProps = GetNamedArg(attr, "IncludeProperties", false);
                    bool includeFields = GetNamedArg(attr, "IncludeFields", false);

                    if (includeCtors)
                        sb.AppendLine($"            _ = typeof({fullName}).GetConstructors(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);");
                    if (includeMethods)
                        sb.AppendLine($"            _ = typeof({fullName}).GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);");
                    if (includeProps)
                        sb.AppendLine($"            _ = typeof({fullName}).GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);");
                    if (includeFields)
                        sb.AppendLine($"            _ = typeof({fullName}).GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);");

                    sb.AppendLine();
                }
            }

            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static bool GetNamedArg(AttributeData? attr, string name, bool defaultValue)
        {
            if (attr == null) return defaultValue;
            foreach (var kv in attr.NamedArguments)
            {
                if (kv.Key == name && kv.Value.Value is bool b)
                    return b;
            }
            return defaultValue;
        }
    }
}
